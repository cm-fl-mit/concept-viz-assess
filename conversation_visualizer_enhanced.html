<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conversation Visualizer - Enhanced</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 40px;
            background-color: white;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
        }
        
        .main-content {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .visualization-panel {
            flex: 2;
        }
        
        .transcript-panel {
            flex: 1;
            min-width: 350px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .header h1 {
            margin: 0 0 5px 0;
            font-size: 20px;
            font-weight: 400;
        }
        
        .header p {
            margin: 0;
            font-size: 14px;
            color: #666;
        }
        
        .controls {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .view-button {
            background: none;
            color: #333;
            border: 1px solid #ddd;
            padding: 8px 16px;
            margin: 0 5px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        
        .view-button:hover {
            background: #f5f5f5;
        }
        
        .view-button.active {
            background: #333;
            color: white;
            border-color: #333;
        }
        
        .visualization {
            min-height: 400px;
        }
        
        .network-container, .timeline-container {
            width: 100%;
            height: 400px;
        }
        
        .hidden {
            display: none;
        }
        
        .node {
            stroke: #fff;
            stroke-width: 2px;
        }
        
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 2;
        }
        
        .timeline-row {
            fill: none;
            stroke: #ddd;
            stroke-width: 1;
        }
        
        .timeline-turn {
            stroke: #fff;
            stroke-width: 1;
            rx: 3;
        }
        
        .timeline-turn:hover {
            cursor: pointer;
        }
        
        .responsive-connection {
            pointer-events: none;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
        }
        
        .legend {
            margin-top: 15px;
            text-align: center;
            font-size: 12px;
            color: #666;
        }
        
        .legend-item {
            display: inline-block;
            margin-right: 15px;
        }
        
        .legend-color {
            display: inline-block;
            width: 8px;
            height: 8px;
            margin-right: 4px;
            border-radius: 50%;
            vertical-align: middle;
        }
        
        .transcript-container {
            border: 1px solid #ddd;
            border-radius: 8px;
            height: 500px;
            overflow-y: auto;
            padding: 15px;
            background: #fafafa;
        }
        
        .transcript-turn {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 6px;
            background: white;
            border-left: 4px solid #ddd;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .transcript-turn:hover {
            background: #f0f8ff;
            border-left-color: #007acc;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .transcript-turn.highlighted {
            background: #fff3cd;
            border-left-color: #ffc107;
            box-shadow: 0 2px 8px rgba(255,193,7,0.3);
        }
        
        .turn-speaker {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .turn-text {
            font-size: 13px;
            line-height: 1.4;
            color: #555;
        }
        
        .turn-time {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }
        
        .edge-mode-control {
            margin-top: 10px;
            text-align: center;
            font-size: 14px;
        }
        
        .edge-mode-control input[type="checkbox"] {
            margin-right: 8px;
        }
        
        .edge-mode-control label {
            cursor: pointer;
            user-select: none;
        }
        
        .edge-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 12px;
            border-radius: 6px;
            font-size: 12px;
            max-width: 300px;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .tooltip-speaker {
            font-weight: bold;
            margin-bottom: 4px;
            color: #ffc107;
        }
        
        .tooltip-text {
            line-height: 1.3;
            margin-bottom: 6px;
        }
        
        .tooltip-arrow {
            font-size: 10px;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Conversation Visualizer - Enhanced</h1>
            <p>Network & Timeline Views with Category Analysis</p>
        </div>
        
        <div class="controls">
            <button class="view-button active" onclick="switchView('network')">Network Graph</button>
            <button class="view-button" onclick="switchView('timeline')">Timeline View</button>
            
            <div class="conversation-source-control" style="margin-left: 30px;">
                <label style="color: white; margin-right: 20px;">Conversation Source:</label>
                <label style="color: white; margin-right: 15px;">
                    <input type="radio" name="conversationSource" value="collaboration" checked onchange="switchConversationSource()"> Collaboration
                </label>
                <label style="color: white;">
                    <input type="radio" name="conversationSource" value="dialogue" onchange="switchConversationSource()"> Dialogue
                </label>
            </div>
        </div>
        
        <div class="controls" id="network-toggle">
            <button class="view-button active" onclick="switchNetworkMode('people')">People Network</button>
            <button class="view-button" onclick="switchNetworkMode('categories')">Category Network</button>
        </div>
        
        <div class="edge-mode-control" id="edge-mode-control" style="display: none;">
            <label>
                <input type="checkbox" id="show-all-edges" onchange="toggleAllEdgesMode()">
                Show All Individual Interactions (Temporal Flow)
            </label>
        </div>
        
        <div class="main-content">
            <div class="visualization-panel">
        <div class="visualization">
            <div id="network-container" class="network-container"></div>
            <div id="timeline-container" class="timeline-container hidden"></div>
                </div>
            </div>
            
            <div class="transcript-panel" id="transcript-panel" style="display: none;">
                <h3 style="margin-top: 0; margin-bottom: 15px; font-size: 16px;">Conversation Transcript</h3>
                <div id="transcript-container" class="transcript-container">
                    <!-- Transcript content will be populated here -->
                </div>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <span class="legend-color" style="background: linear-gradient(45deg, #FF6B6B, #4ECDC4);"></span>
                People (colored by speaker)
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background: linear-gradient(45deg, #4CAF50, #2196F3);"></span>
                Categories (colored by type)
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background: linear-gradient(45deg, #FF6B6B, #96CEB4);"></span>
                Gradient connections
            </div>
        </div>
    </div>

    <script>
        let conversationData = null;
        let currentView = 'network';
        let currentNetworkMode = 'people';
        let showAllEdges = false;
        let conversationSource = 'collaboration';
        
        // Load conversation data
        async function loadConversationData() {
            try {
                let response;
                
                if (conversationSource === 'collaboration') {
                    // Try to load collaboration conversation data
                    response = await fetch('collaboration_conversations/productive_conversation_analysis.json');
                } else if (conversationSource === 'dialogue') {
                    // Try to load dialogue conversation data
                    response = await fetch('dialogue_conversations/productive_dialogue_analysis.json');
                }
                
                // Fallback to other files if the primary source fails
                if (!response.ok) {
                    response = await fetch('converted_conversation_2364_reduced_features.json');
                    if (!response.ok) {
                        response = await fetch('converted_conversation_2364_merged_features.json');
                        if (!response.ok) {
                            response = await fetch('converted_conversation_2364_with_ids_annotated.json');
                if (!response.ok) {
                    response = await fetch('converted_conversation_2364_with_ids.json');
                            }
                        }
                    }
                }
                conversationData = await response.json();
                
                // Limit conversation to first 50 turns for better performance and readability
                if (conversationData.turns && conversationData.turns.length > 50) {
                    conversationData.turns = conversationData.turns.slice(0, 50);
                    
                    // Also filter links to only include those involving the first 50 turns
                    const validTurnIds = new Set(conversationData.turns.map(turn => turn.id));
                    if (conversationData.links) {
                        conversationData.links = conversationData.links.filter(link => 
                            validTurnIds.has(link.source) && validTurnIds.has(link.target)
                        );
                    }
                    
                    console.log('Limited conversation data to first 50 turns');
                }
                
                console.log('Loaded conversation data:', conversationData);
                initializeVisualizations();
            } catch (error) {
                console.error('Error loading conversation data:', error);
                document.querySelector('.visualization').innerHTML = 
                    '<p style="text-align: center; color: red;">Error loading conversation data. Please ensure the JSON file is in the same directory.</p>';
            }
        }
        
        function switchView(view) {
            currentView = view;
            
            // Update button states
            document.querySelectorAll('.view-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Show/hide network toggle, edge mode control, and transcript panel
            const networkToggle = document.getElementById('network-toggle');
            const edgeModeControl = document.getElementById('edge-mode-control');
            const transcriptPanel = document.getElementById('transcript-panel');
            
            if (view === 'network') {
                networkToggle.style.display = 'block';
                edgeModeControl.style.display = 'block';
                transcriptPanel.style.display = 'block';
            } else {
                networkToggle.style.display = 'none';
                edgeModeControl.style.display = 'none';
                transcriptPanel.style.display = 'none';
            }
            
            // Show/hide containers
            const networkContainer = document.getElementById('network-container');
            const timelineContainer = document.getElementById('timeline-container');
            
            if (view === 'network') {
                networkContainer.classList.remove('hidden');
                timelineContainer.classList.add('hidden');
                renderNetworkGraph();
                renderTranscript();
            } else {
                networkContainer.classList.add('hidden');
                timelineContainer.classList.remove('hidden');
                renderTimeline();
            }
        }
        
        function switchNetworkMode(mode) {
            currentNetworkMode = mode;
            
            // Update button states
            document.querySelectorAll('#network-toggle .view-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Re-render network graph
            renderNetworkGraph();
        }
        
        function toggleAllEdgesMode() {
            showAllEdges = document.getElementById('show-all-edges').checked;
            renderNetworkGraph();
        }
        
        function switchConversationSource() {
            const selectedSource = document.querySelector('input[name="conversationSource"]:checked').value;
            conversationSource = selectedSource;
            
            // Reload conversation data with new source
            loadConversationData();
        }
        
        function initializeVisualizations() {
            // Ensure UI elements are properly set for initial view
            const networkToggle = document.getElementById('network-toggle');
            const edgeModeControl = document.getElementById('edge-mode-control');
            const transcriptPanel = document.getElementById('transcript-panel');
            
            if (currentView === 'network') {
                // Make sure network controls and transcript are visible
                networkToggle.style.display = 'block';
                edgeModeControl.style.display = 'block';
                transcriptPanel.style.display = 'block';
                
                // Set the network button as active by default
                document.querySelector('[onclick="switchView(\'network\')"]').classList.add('active');
                
                renderNetworkGraph();
                renderTranscript();
            } else {
                // Hide network controls for timeline view
                networkToggle.style.display = 'none';
                edgeModeControl.style.display = 'none';
                transcriptPanel.style.display = 'none';
                
                renderTimeline();
            }
        }
        
        function renderNetworkGraph() {
            const container = document.getElementById('network-container');
            container.innerHTML = '';
            
            if (!conversationData || !conversationData.turns) return;
            
            if (currentNetworkMode === 'people') {
                renderPeopleNetwork();
            } else {
                renderCategoryNetwork();
            }
        }
        
        function renderPeopleNetwork() {
            const container = document.getElementById('network-container');
            
            // Limit to first 50 turns for all-edges mode testing
            const turnsToProcess = conversationData.turns;
            
            if (showAllEdges) {
                renderAllEdgesNetwork(turnsToProcess);
                return;
            }
            
            // Calculate participation metrics for each speaker
            const speakerStats = {};
            const connections = [];
            
            // Create ID to name mapping
            const idToName = {};
            conversationData.people.forEach(person => {
                idToName[person.id] = person.name;
            });

            // Process turns to build speaker stats
            turnsToProcess.forEach(turn => {
                const speakerId = turn.speaker_id;
                const speakerName = idToName[speakerId];
                
                // Initialize speaker stats
                if (!speakerStats[speakerId]) {
                    speakerStats[speakerId] = {
                        id: speakerId,
                        name: speakerName,
                        totalWords: 0,
                        totalDuration: 0,
                        turnCount: 0
                    };
                }
                
                // Get word count from features or calculate from text
                const wordCountFeature = turn.features.find(f => f.name === 'word_count');
                const wordCount = wordCountFeature ? wordCountFeature.value : turn.text.split(' ').length;
                
                const durationFeature = turn.features.find(f => f.name === 'turn_duration');
                const duration = durationFeature ? durationFeature.value : (turn.end_time - turn.start_time);
                
                // Update speaker stats
                speakerStats[speakerId].totalWords += wordCount;
                speakerStats[speakerId].totalDuration += duration;
                speakerStats[speakerId].turnCount += 1;
            });
            
            // Process links for substantive responsivity connections
            conversationData.links.forEach(link => {
                const responsivityFeature = link.features.find(f => f.name === 'responsivity_strength');
                
                // Only include substantive responses (value >= 2)
                if (responsivityFeature && responsivityFeature.value >= 2) {
                    const sourceTurn = conversationData.turns.find(t => t.id === link.source);
                    const targetTurn = conversationData.turns.find(t => t.id === link.target);
                    
                    if (sourceTurn && targetTurn && sourceTurn.speaker_id !== targetTurn.speaker_id) {
                        connections.push({
                            source: sourceTurn.speaker_id,
                            target: targetTurn.speaker_id,
                            weight: responsivityFeature.value,
                            type: 'substantive'
                        });
                    }
                }
            });
            
            // Aggregate connections
            const connectionMap = new Map();
            connections.forEach(conn => {
                const key = `${conn.source}-${conn.target}`;
                if (connectionMap.has(key)) {
                    connectionMap.get(key).weight += 1;
                } else {
                    connectionMap.set(key, {
                        source: conn.source,
                        target: conn.target,
                        weight: conn.weight,
                        type: conn.type
                    });
                }
            });
            
            const aggregatedConnections = Array.from(connectionMap.values());
            const speakers = Object.keys(speakerStats);
            
            // Create D3 visualization
            const width = container.clientWidth;
            const height = 400;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Calculate node sizes based on participation
            const maxWords = d3.max(Object.values(speakerStats), d => d.totalWords);
            const nodeSizeScale = d3.scaleLinear()
                .domain([0, maxWords])
                .range([8, 25]);
            
            // Create force simulation
            const nodeData = speakers.map(speakerId => ({ 
                id: Number(speakerId), 
                name: speakerStats[speakerId].name,
                size: nodeSizeScale(speakerStats[speakerId].totalWords),
                x: width / 2,
                y: height / 2
            }));

            // Process connections to ensure they reference actual nodes
            const validConnections = aggregatedConnections.filter(conn => {
                const sourceExists = nodeData.some(n => n.id === conn.source);
                const targetExists = nodeData.some(n => n.id === conn.target);
                return sourceExists && targetExists;
            });
            
            const simulation = d3.forceSimulation(nodeData)
                .force('x', d3.forceX(width / 2).strength(0.1))
                .force('y', d3.forceY(height / 2).strength(0.1))
                .force('link', d3.forceLink(validConnections)
                    .id(d => d.id)
                    .distance(d => 30 + d.source.size + d.target.size)
                    .strength(0.1))
                .force('charge', d3.forceManyBody()
                    .strength(d => -500 * Math.sqrt(d.size)))
                .force('collision', d3.forceCollide()
                    .radius(d => d.size + 5)
                    .strength(0.8))
                .alphaDecay(0.01)
                .velocityDecay(0.4);

            // Create gradient definitions for edges
            const defs = svg.append('defs');
            
            // Create directional grey gradients (dark source to light target)
            const peopleColors = ['#7B7B7B', '#A5A5A5', '#8C8C8C', '#999999', '#808080', '#737373'];
            validConnections.forEach((conn, i) => {
                const sourceId = typeof conn.source === 'object' ? conn.source.id : conn.source;
                const targetId = typeof conn.target === 'object' ? conn.target.id : conn.target;
                
                // Create unique gradient ID for each connection direction
                const gradientId = `gradient-${i}-${sourceId}-to-${targetId}`;
                const gradient = defs.append('linearGradient')
                    .attr('id', gradientId)
                    .attr('x1', '0%').attr('y1', '0%')
                    .attr('x2', '100%').attr('y2', '0%');
                
                gradient.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', '#404040')  // Dark grey at source
                    .attr('stop-opacity', 0.8);
                
                gradient.append('stop')
                    .attr('offset', '100%')
                    .attr('stop-color', '#CCCCCC')  // Light grey at target
                    .attr('stop-opacity', 0.8);
            });

            // Create curved links with gradient colors
            const link = svg.append('g')
                .selectAll('path')
                .data(validConnections)
                .enter().append('path')
                .attr('class', 'link')
                .style('stroke', (d, i) => {
                    const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                    const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                    return `url(#gradient-${i}-${sourceId}-to-${targetId})`;
                })
                .style('stroke-width', d => Math.max(3, Math.sqrt(d.weight) * 2))
                .style('stroke-opacity', 1.0)
                .style('fill', 'none')

            
            // Use the same color array for node coloring
            const colorScale = d3.scaleOrdinal(peopleColors);
            
            // Create nodes with unique colors
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodeData)
                .enter().append('circle')
                .attr('class', 'node')
                .attr('r', d => d.size)
                .attr('fill', d => colorScale(d.id))
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // Add labels inside nodes
            const label = svg.append('g')
                .selectAll('text')
                .data(nodeData)
                .enter().append('text')
                .text(d => d.name.split(' ')[0]) // First name only for space
                .attr('dy', '.35em')
                .attr('text-anchor', 'middle')
                .style('font-size', d => Math.min(12, d.size * 0.4) + 'px')
                .style('fill', 'white')
                .style('font-weight', 'bold')
                .style('text-shadow', '1px 1px 2px rgba(0,0,0,0.8)')
                .style('pointer-events', 'none');
            
            // Update positions on simulation tick
            simulation.on('tick', () => {
                // Constrain nodes to visualization bounds
                node.each(d => {
                    d.x = Math.max(d.size, Math.min(width - d.size, d.x));
                    d.y = Math.max(d.size, Math.min(height - d.size, d.y));
                });

                link
                    .attr('d', d => {
                        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                        const sourceNode = simulation.nodes().find(n => n.id === sourceId);
                        const targetNode = simulation.nodes().find(n => n.id === targetId);
                        
                        if (!sourceNode || !targetNode) return '';
                        
                        const dx = targetNode.x - sourceNode.x;
                        const dy = targetNode.y - sourceNode.y;
                        const dr = Math.sqrt(dx * dx + dy * dy);
                        
                        // Calculate offset to avoid overlapping with nodes
                        const sourceRadius = sourceNode.size || 10;
                        const targetRadius = targetNode.size || 10;
                        
                        // Adjust start and end points to be on the edge of the nodes
                        const startX = sourceNode.x + (dx / dr) * sourceRadius;
                        const startY = sourceNode.y + (dy / dr) * sourceRadius;
                        const endX = targetNode.x - (dx / dr) * targetRadius;
                        const endY = targetNode.y - (dy / dr) * targetRadius;
                        
                        // Create directional curves - bend different ways for each direction
                        // Use the relative IDs to determine curve direction consistently
                        const curveDirection = sourceId < targetId ? -1 : 1;
                        const curveOffset = 30 * curveDirection;
                        
                        return `M ${startX} ${startY} Q ${(startX + endX) / 2} ${(startY + endY) / 2 + curveOffset} ${endX} ${endY}`;
                    });
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }
        
        function renderCategoryNetwork() {
            const container = document.getElementById('network-container');
            
            // Limit to first 50 turns for consistency
            const turnsToProcess = conversationData.turns;
            
            if (showAllEdges) {
                renderAllEdgesCategoryNetwork(turnsToProcess);
                return;
            }
            
            // Define category features (productive conversation analysis set)
            const categoryFeatureNames = ['agreement', 'disagreement', 'new_idea', 'collaborative_building', 'curiosity', 'uncertainty'];
            
            // Check if category features are available
            if (!turnsToProcess[0].features) {
                container.innerHTML = '<p style="text-align: center; color: red;">No features found in turn data.</p>';
                return;
            }
            
            // Collect categories that exist as features
            const allCategories = new Set();
            turnsToProcess.forEach(turn => {
                if (turn.features) {
                    turn.features.forEach(feature => {
                        if (categoryFeatureNames.includes(feature.name)) {
                            allCategories.add(feature.name);
                        }
                    });
                }
            });
            
            const categories = Array.from(allCategories);
            
            if (categories.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: red;">No category features found. Showing people network instead.</p>';
                renderPeopleNetwork();
                return;
            }
            
            // Count category occurrences and calculate average values
            const categoryStats = {};
            categories.forEach(cat => {
                categoryStats[cat] = {
                    id: cat,
                    name: cat,
                    count: 0,
                    totalValue: 0,
                    avgValue: 0,
                    size: 0
                };
            });
            
            // Count occurrences and sum values for categories (threshold > 0.5)
            turnsToProcess.forEach(turn => {
                if (turn.features) {
                    turn.features.forEach(feature => {
                        if (categoryFeatureNames.includes(feature.name) && feature.value > 0.5) {
                            if (categoryStats[feature.name]) {
                                categoryStats[feature.name].count += 1;
                                categoryStats[feature.name].totalValue += feature.value;
                            }
                        }
                    });
                }
            });
            
            // Calculate average values
            Object.values(categoryStats).forEach(cat => {
                if (cat.count > 0) {
                    cat.avgValue = cat.totalValue / cat.count;
                }
            });
            
            // Calculate node sizes based on frequency
            const maxCount = d3.max(Object.values(categoryStats), d => d.count);
            const nodeSizeScale = d3.scaleLinear()
                .domain([0, maxCount])
                .range([10, 30]);
            
            // Update sizes
            Object.values(categoryStats).forEach(cat => {
                cat.size = nodeSizeScale(cat.count);
            });
            
            // Create connections between categories based on turn sequences
            const connections = [];
            
            // Helper function to get active categories for a turn (features with value > 0.5)
            function getActiveCategoriesForTurn(turn) {
                const activeCategories = [];
                if (turn.features) {
                    turn.features.forEach(feature => {
                        if (categoryFeatureNames.includes(feature.name) && feature.value > 0.5) {
                            activeCategories.push(feature.name);
                        }
                    });
                }
                return activeCategories;
            }
            
            for (let i = 0; i < turnsToProcess.length - 1; i++) {
                const currentTurn = turnsToProcess[i];
                const nextTurn = turnsToProcess[i + 1];
                
                const currentCategories = getActiveCategoriesForTurn(currentTurn);
                const nextCategories = getActiveCategoriesForTurn(nextTurn);
                
                if (currentCategories.length > 0 && nextCategories.length > 0) {
                    // Create connections between categories in consecutive turns
                    currentCategories.forEach(sourceCat => {
                        nextCategories.forEach(targetCat => {
                            if (sourceCat !== targetCat) {
                                connections.push({
                                    source: sourceCat,
                                    target: targetCat,
                                    weight: 1,
                                    type: 'sequence'
                                });
                            }
                        });
                    });
                }
                    
                    // Also create connections within the same turn
                if (currentCategories.length > 1) {
                    currentCategories.forEach(sourceCat => {
                        currentCategories.forEach(targetCat => {
                            if (sourceCat !== targetCat) {
                                connections.push({
                                    source: sourceCat,
                                    target: targetCat,
                                    weight: 1,
                                    type: 'co-occurrence'
                                });
                            }
                        });
                    });
                }
            }
            
            // Aggregate connections
            const connectionMap = new Map();
            connections.forEach(conn => {
                const key = `${conn.source}-${conn.target}`;
                if (connectionMap.has(key)) {
                    connectionMap.get(key).weight += 1;
                } else {
                    connectionMap.set(key, {
                        source: conn.source,
                        target: conn.target,
                        weight: conn.weight,
                        type: conn.type
                    });
                }
            });
            
            const aggregatedConnections = Array.from(connectionMap.values());
            
            // Create D3 visualization
            const width = container.clientWidth;
            const height = 400;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Create node data
            const nodeData = Object.values(categoryStats).map(cat => ({
                id: cat.id,
                name: cat.name,
                size: cat.size,
                count: cat.count,
                x: width / 2,
                y: height / 2
            }));
            
            // Filter valid connections
            const validConnections = aggregatedConnections.filter(conn => {
                const sourceExists = nodeData.some(n => n.id === conn.source);
                const targetExists = nodeData.some(n => n.id === conn.target);
                return sourceExists && targetExists;
            });
            
            const simulation = d3.forceSimulation(nodeData)
                .force('x', d3.forceX(width / 2).strength(0.1))
                .force('y', d3.forceY(height / 2).strength(0.1))
                .force('link', d3.forceLink(validConnections)
                    .id(d => d.id)
                    .distance(d => 30 + d.source.size + d.target.size)
                    .strength(0.1))
                .force('charge', d3.forceManyBody()
                    .strength(d => -500 * Math.sqrt(d.size)))
                .force('collision', d3.forceCollide()
                    .radius(d => d.size + 5)
                    .strength(0.8))
                .alphaDecay(0.01)
                .velocityDecay(0.4);
            // Create gradient definitions for category edges
            const defs = svg.append('defs');
            const categoryColors = {
                'agreement': '#4CAF50',
                'disagreement': '#FF5722', 
                'new_idea': '#2196F3',
                'collaborative_building': '#9C27B0',
                'curiosity': '#FF9800',
                'uncertainty': '#607D8B'
            };
            
            // Create gradients for each category combination
            validConnections.forEach((conn, i) => {
                const sourceColor = categoryColors[conn.source] || '#666';
                const targetColor = categoryColors[conn.target] || '#666';
                
                const gradientId = `cat-gradient-${conn.source}-${conn.target}`;
                const gradient = defs.append('linearGradient')
                    .attr('id', gradientId)
                    .attr('x1', '0%').attr('y1', '0%')
                    .attr('x2', '100%').attr('y2', '0%');
                
                gradient.append('stop')
                    .attr('offset', '0%')
                    .attr('stop-color', sourceColor)
                    .attr('stop-opacity', 0.7);
                
                gradient.append('stop')
                    .attr('offset', '100%')
                    .attr('stop-color', targetColor)
                    .attr('stop-opacity', 0.7);
            });

            // Create curved links with gradient colors
            const link = svg.append('g')
                .selectAll('path')
                .data(validConnections)
                .enter().append('path')
                .attr('class', 'link')
                .style('stroke', d => {
                    return `url(#cat-gradient-${d.source}-${d.target})`;
                })
                .style('stroke-width', d => Math.max(2, Math.sqrt(d.weight) * 2))
                .style('stroke-opacity', 1.0)
                .style('fill', 'none')
            
            
            // Use the same category colors defined above
            
            // Create nodes with category-specific colors
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodeData)
                .enter().append('circle')
                .attr('class', 'node')
                .attr('r', d => d.size)
                .attr('fill', d => categoryColors[d.id] || '#666')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // Add labels inside nodes
            const label = svg.append('g')
                .selectAll('text')
                .data(nodeData)
                .enter().append('text')
                .text(d => d.name.split(' ')[0]) // First word only for space
                .attr('dy', '.35em')
                .attr('text-anchor', 'middle')
                .style('font-size', d => Math.min(11, d.size * 0.35) + 'px')
                .style('fill', 'white')
                .style('font-weight', 'bold')
                .style('text-shadow', '1px 1px 2px rgba(0,0,0,0.8)')
                .style('pointer-events', 'none');
            
            // Update positions on simulation tick
            simulation.on('tick', () => {
                // Constrain nodes to visualization bounds
                node.each(d => {
                    d.x = Math.max(d.size, Math.min(width - d.size, d.x));
                    d.y = Math.max(d.size, Math.min(height - d.size, d.y));
                });

                link
                    .attr('d', d => {
                        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                        const sourceNode = simulation.nodes().find(n => n.id === sourceId);
                        const targetNode = simulation.nodes().find(n => n.id === targetId);
                        
                        if (!sourceNode || !targetNode) return '';
                        
                        const dx = targetNode.x - sourceNode.x;
                        const dy = targetNode.y - sourceNode.y;
                        const dr = Math.sqrt(dx * dx + dy * dy);
                        
                        // Calculate offset to avoid overlapping with nodes
                        const sourceRadius = sourceNode.size || 10;
                        const targetRadius = targetNode.size || 10;
                        
                        // Adjust start and end points to be on the edge of the nodes
                        const startX = sourceNode.x + (dx / dr) * sourceRadius;
                        const startY = sourceNode.y + (dy / dr) * sourceRadius;
                        const endX = targetNode.x - (dx / dr) * targetRadius;
                        const endY = targetNode.y - (dy / dr) * targetRadius;
                        
                        // Create directional curves - bend different ways for each direction
                        // Use the relative IDs to determine curve direction consistently
                        const curveDirection = sourceId < targetId ? -1 : 1;
                        const curveOffset = 30 * curveDirection;
                        
                        return `M ${startX} ${startY} Q ${(startX + endX) / 2} ${(startY + endY) / 2 + curveOffset} ${endX} ${endY}`;
                    });
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }
        
        function renderTimeline() {
            const container = document.getElementById('timeline-container');
            container.innerHTML = '';
            
            if (!conversationData || !conversationData.turns) return;
            
            // Extract speakers and their turns
            const speakers = new Set();
            const turns = [];
            const responsiveConnections = [];
            
            // Create ID to name mapping
            const idToName = {};
            conversationData.people.forEach(person => {
                idToName[person.id] = person.name;
            });

            // Generate timeline data - handle missing start_time/end_time
            let currentTime = 0;
            conversationData.turns.forEach((turn, index) => {
                const speakerName = idToName[turn.speaker_id];
                speakers.add(speakerName);
                
                // Calculate timing - use existing times or generate from duration/word count
                let startTime, endTime, duration;
                
                if (turn.start_time !== undefined && turn.end_time !== undefined) {
                    // Use existing timing data
                    startTime = turn.start_time;
                    endTime = turn.end_time;
                    duration = endTime - startTime;
                } else {
                    // Generate timing from turn_duration feature or estimate from word count
                    const durationFeature = turn.features?.find(f => f.name === 'turn_duration');
                    const wordCountFeature = turn.features?.find(f => f.name === 'word_count');
                    
                    if (durationFeature) {
                        duration = durationFeature.value;
                    } else if (wordCountFeature) {
                        // Estimate: ~150 words per minute = 2.5 words per second
                        duration = wordCountFeature.value / 2.5;
                    } else {
                        // Fallback: estimate from text length
                        const wordCount = turn.text.split(/\s+/).length;
                        duration = wordCount / 2.5;
                    }
                    
                    startTime = currentTime;
                    endTime = currentTime + duration;
                    currentTime = endTime + 1; // Add 1 second gap between turns
                }
                
                turns.push({
                    id: turn.id,
                    speaker_id: turn.speaker_id,
                    speaker: speakerName,
                    start_time: startTime,
                    end_time: endTime,
                    text: turn.text,
                    words: turn.text.substring(0, 100) + (turn.text.length > 100 ? '...' : ''),
                    duration: duration
                });
            });
            
            // Extract substantive responsivity connections for timeline
            conversationData.links.forEach(link => {
                const responsivityFeature = link.features.find(f => f.name === 'responsivity_strength');
                
                // Only include substantive responses (value >= 2)
                if (responsivityFeature && responsivityFeature.value >= 2) {
                    const sourceTurn = turns.find(t => t.id === link.source);
                    const targetTurn = turns.find(t => t.id === link.target);
                    
                    if (sourceTurn && targetTurn) {
                        responsiveConnections.push({
                            source: {
                                id: sourceTurn.id,
                                speaker_id: sourceTurn.speaker_id,
                                speaker: sourceTurn.speaker,
                                start_time: sourceTurn.start_time,
                                end_time: sourceTurn.end_time
                            },
                            target: {
                                id: targetTurn.id,
                                speaker_id: targetTurn.speaker_id,
                                speaker: targetTurn.speaker,
                                start_time: targetTurn.start_time,
                                end_time: targetTurn.end_time
                            },
                            strength: responsivityFeature.value
                        });
                    }
                }
            });
            
            const speakerArray = Array.from(speakers);
            const width = container.clientWidth;
            const height = 240;
            const margin = { top: 15, right: 15, bottom: 40, left: 100 };
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Create scales
            const xScale = d3.scaleLinear()
                .domain([0, d3.max(turns, d => d.end_time)])
                .range([margin.left, width - margin.right]);
            
            const yScale = d3.scaleBand()
                .domain(speakerArray)
                .range([margin.top, height - margin.bottom])
                .padding(0.1);
            
            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(xScale)
                    .tickFormat(d => `${Math.floor(d/60)}m`)
                    .ticks(8))
                .selectAll('text')
                .style('font-size', '12px')
                .style('fill', '#666');
            
            svg.append('g')
                .attr('transform', `translate(${margin.left},0)`)
                .call(d3.axisLeft(yScale))
                .selectAll('text')
                .style('font-size', '12px')
                .style('fill', '#666');
            
            // Add speaker rows
            svg.append('g')
                .selectAll('line')
                .data(speakerArray)
                .enter().append('line')
                .attr('class', 'timeline-row')
                .attr('x1', margin.left)
                .attr('x2', width - margin.right)
                .attr('y1', d => yScale(d) + yScale.bandwidth() / 2)
                .attr('y2', d => yScale(d) + yScale.bandwidth() / 2);
            
            // Create tooltip for timeline
            const timelineTooltip = d3.select('body').append('div')
                .attr('class', 'edge-tooltip')
                .style('opacity', 0);
            
            // Helper function to get feature-based colors for a turn
            function getTurnColors(turn) {
                const categoryFeatureNames = ['agreement', 'disagreement', 'new_idea', 'collaborative_building', 'curiosity', 'uncertainty'];
                const categoryColors = {
                    'agreement': '#4CAF50',
                    'disagreement': '#FF5722', 
                    'new_idea': '#2196F3',
                    'collaborative_building': '#9C27B0',
                    'curiosity': '#FF9800',
                    'uncertainty': '#607D8B'
                };
                
                const activeConcepts = [];
                if (turn.features) {
                    turn.features.forEach(feature => {
                        if (categoryFeatureNames.includes(feature.name) && feature.value > 0.5) {
                            activeConcepts.push(feature.name);
                        }
                    });
                }
                
                if (activeConcepts.length === 0) {
                    return ['#666']; // Default gray if no features
                } else if (activeConcepts.length === 1) {
                    return [categoryColors[activeConcepts[0]]];
                } else {
                    // Multiple colors - create gradient or stripe pattern
                    return activeConcepts.map(concept => categoryColors[concept]);
                }
            }
            
            // Helper function to create fill pattern for multiple colors
            function createFillPattern(colors, turnId) {
                if (colors.length === 1) {
                    return colors[0];
                } else {
                    // Create a gradient pattern
                    const gradientId = `timeline-gradient-${turnId}`;
                    const gradient = svg.append('defs')
                        .append('linearGradient')
                        .attr('id', gradientId)
                        .attr('x1', '0%').attr('y1', '0%')
                        .attr('x2', '100%').attr('y2', '0%');
                    
                    const stepSize = 100 / colors.length;
                    colors.forEach((color, i) => {
                        gradient.append('stop')
                            .attr('offset', `${i * stepSize}%`)
                            .attr('stop-color', color);
                        gradient.append('stop')
                            .attr('offset', `${(i + 1) * stepSize}%`)
                            .attr('stop-color', color);
                    });
                    
                    return `url(#${gradientId})`;
                }
            }
            
            // Find turn data for coloring
            const turnsToProcess = conversationData.turns;
            const turnDataMap = new Map();
            turnsToProcess.forEach(turn => {
                turnDataMap.set(turn.id, turn);
            });
            
            // Add turns with feature-based coloring
            svg.append('g')
                .selectAll('rect')
                .data(turns)
                .enter().append('rect')
                .attr('class', 'timeline-turn')
                .attr('x', d => xScale(d.start_time))
                .attr('y', d => yScale(d.speaker) + yScale.bandwidth() * 0.1)
                .attr('width', d => Math.max(2, xScale(d.end_time) - xScale(d.start_time)))
                .attr('height', yScale.bandwidth() * 0.8)
                .attr('fill', d => {
                    const turnData = turnDataMap.get(d.id);
                    if (turnData) {
                        const colors = getTurnColors(turnData);
                        return createFillPattern(colors, d.id);
                    }
                    return '#333'; // Default color
                })
                .attr('stroke', '#fff')
                .attr('stroke-width', 1)
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    // Highlight this turn
                    d3.select(this).attr('stroke', '#ffc107').attr('stroke-width', 2);
                    
                    // Get turn features for tooltip
                    const turnData = turnDataMap.get(d.id);
                    let featuresText = '';
                    if (turnData && turnData.features) {
                        const categoryFeatureNames = ['agreement', 'disagreement', 'new_idea', 'collaborative_building', 'curiosity', 'uncertainty'];
                        const activeFeatures = turnData.features
                            .filter(f => categoryFeatureNames.includes(f.name) && f.value > 0.5)
                            .map(f => `${f.name} (${f.value.toFixed(1)})`)
                            .join(', ');
                        featuresText = activeFeatures ? `<br><strong>Features:</strong> ${activeFeatures}` : '';
                    }
                    
                    // Show tooltip
                    timelineTooltip.transition().duration(200).style('opacity', 1);
                    timelineTooltip.html(`
                        <div class="tooltip-speaker">${d.speaker}:</div>
                        <div class="tooltip-text">${d.text}</div>
                        <div style="font-size: 10px; color: #ccc; margin-top: 8px;">
                            ${Math.floor(d.start_time/60)}:${(Math.floor(d.start_time%60)).toString().padStart(2,'0')} - 
                            ${Math.floor(d.end_time/60)}:${(Math.floor(d.end_time%60)).toString().padStart(2,'0')}
                            ${featuresText}
                        </div>
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function(event, d) {
                    // Reset turn
                    d3.select(this).attr('stroke', '#fff').attr('stroke-width', 1);
                    
                    // Hide tooltip
                    timelineTooltip.transition().duration(200).style('opacity', 0);
                });
            
            // Add responsive connections with curved black lines
            svg.append('g')
                .selectAll('path')
                .data(responsiveConnections)
                .enter().append('path')
                .attr('class', 'responsive-connection')
                .attr('d', d => {
                    const x1 = xScale(d.source.end_time);
                    const y1 = yScale(d.source.speaker) + yScale.bandwidth() / 2;
                    const x2 = xScale(d.target.start_time);
                    const y2 = yScale(d.target.speaker) + yScale.bandwidth() / 2;
                    
                    // Create a curved path
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const curveHeight = Math.abs(dy) * 0.3 + 20; // Curve based on vertical distance
                    const midX = x1 + dx * 0.5;
                    const midY = y1 + dy * 0.5 - curveHeight;
                    
                    return `M ${x1} ${y1} Q ${midX} ${midY} ${x2} ${y2}`;
                })
                .style('stroke', '#000000')
                .style('stroke-width', d => Math.max(1, d.strength * 0.8))
                .style('stroke-opacity', 0.8)
                .style('fill', 'none'); // Important for path elements
        }
        
        function renderTranscript() {
            const container = document.getElementById('transcript-container');
            container.innerHTML = '';
            
            if (!conversationData || !conversationData.turns) return;
            
            // Use all available turns (already limited to 50 in loadConversationData)
            const turnsToShow = conversationData.turns;
            
            // Create ID to name mapping
            const idToName = {};
            conversationData.people.forEach(person => {
                idToName[person.id] = person.name;
            });
            
            // Create color mapping for speakers
            const peopleColors = ['#7B7B7B', '#A5A5A5', '#8C8C8C', '#999999', '#808080', '#737373'];
            
            turnsToShow.forEach(turn => {
                const turnDiv = document.createElement('div');
                turnDiv.className = 'transcript-turn';
                turnDiv.setAttribute('data-turn-id', turn.id);
                turnDiv.setAttribute('data-speaker-id', turn.speaker_id);
                
                const speakerColor = peopleColors[turn.speaker_id % peopleColors.length];
                turnDiv.style.borderLeftColor = speakerColor;
                
                const speakerDiv = document.createElement('div');
                speakerDiv.className = 'turn-speaker';
                speakerDiv.style.color = speakerColor;
                speakerDiv.textContent = idToName[turn.speaker_id] || `Speaker ${turn.speaker_id}`;
                
                const textDiv = document.createElement('div');
                textDiv.className = 'turn-text';
                textDiv.textContent = turn.text;
                
                const timeDiv = document.createElement('div');
                timeDiv.className = 'turn-time';
                const startMin = Math.floor(turn.start_time / 60);
                const startSec = Math.floor(turn.start_time % 60);
                timeDiv.textContent = `${startMin}:${startSec.toString().padStart(2, '0')}`;
                
                turnDiv.appendChild(speakerDiv);
                turnDiv.appendChild(textDiv);
                turnDiv.appendChild(timeDiv);
                
                // Add hover highlighting
                turnDiv.addEventListener('mouseenter', () => highlightNode(turn.speaker_id, turn.id));
                turnDiv.addEventListener('mouseleave', () => unhighlightNodes());
                
                container.appendChild(turnDiv);
            });
        }
        
        function highlightNode(speakerId, turnId = null) {
            if (currentNetworkMode === 'people') {
                highlightSpeakerAndEdges(speakerId, turnId);
            } else {
                highlightConceptsAndEdges(turnId);
            }
        }
        
        function highlightSpeakerAndEdges(speakerId, turnId) {
            const turnsToProcess = conversationData.turns;
            
            // Find current turn and its position
            let currentTurnIndex = -1;
            let prevSpeakerId = null;
            let nextSpeakerId = null;
            
            if (turnId && turnsToProcess) {
                currentTurnIndex = turnsToProcess.findIndex(t => t.id === turnId);
                if (currentTurnIndex > 0) {
                    prevSpeakerId = turnsToProcess[currentTurnIndex - 1].speaker_id;
                }
                if (currentTurnIndex < turnsToProcess.length - 1) {
                    nextSpeakerId = turnsToProcess[currentTurnIndex + 1].speaker_id;
                }
            }
            
            // Highlight nodes
            const nodes = document.querySelectorAll('.node');
            const labels = document.querySelectorAll('text');
            
            nodes.forEach(node => {
                const nodeData = d3.select(node).datum();
                if (nodeData && nodeData.id === speakerId) {
                    d3.select(node)
                        .style('stroke', '#ffc107')
                        .style('stroke-width', '4px')
                        .style('opacity', '1');
                } else if (nodeData && (nodeData.id === prevSpeakerId || nodeData.id === nextSpeakerId)) {
                    d3.select(node)
                        .style('stroke', '#28a745')
                        .style('stroke-width', '3px')
                        .style('opacity', '0.8');
                } else {
                    d3.select(node).style('opacity', '0.2');
                }
            });
            
            labels.forEach(label => {
                const labelData = d3.select(label).datum();
                if (labelData && (labelData.id === speakerId || labelData.id === prevSpeakerId || labelData.id === nextSpeakerId)) {
                    d3.select(label).style('opacity', '1');
                } else {
                    d3.select(label).style('opacity', '0.2');
                }
            });
            
            // Handle edge highlighting differently for temporal flow vs aggregated mode
            const links = document.querySelectorAll('.link');
            
            if (showAllEdges && currentTurnIndex >= 0) {
                // Temporal flow mode: highlight only edges from this specific turn
                links.forEach(link => {
                    const linkData = d3.select(link).datum();
                    if (linkData) {
                        // Check if this edge corresponds to the current turn transition
                        let isRelevantEdge = false;
                        
                        // Edge from current turn to next turn
                        if (linkData.turnIndex === currentTurnIndex && 
                            linkData.source === speakerId && 
                            linkData.target === nextSpeakerId) {
                            isRelevantEdge = true;
                        }
                        
                        // Edge from previous turn to current turn
                        if (linkData.turnIndex === currentTurnIndex - 1 && 
                            linkData.source === prevSpeakerId && 
                            linkData.target === speakerId) {
                            isRelevantEdge = true;
                        }
                        
                        if (isRelevantEdge) {
                            d3.select(link)
                                .style('stroke-opacity', '1.0')
                                .style('stroke-width', 5);
                        } else {
                            d3.select(link)
                                .style('stroke-opacity', '0.05')
                                .style('stroke-width', 1);
                        }
                    }
                });
            } else {
                // Aggregated mode: highlight edges connected to relevant speakers
                links.forEach(link => {
                    const linkData = d3.select(link).datum();
                    if (linkData) {
                        const sourceId = typeof linkData.source === 'object' ? linkData.source.id : linkData.source;
                        const targetId = typeof linkData.target === 'object' ? linkData.target.id : linkData.target;
                        
                        // Highlight edges connected to the main speaker, previous, or next speaker
                        if ((sourceId === speakerId || targetId === speakerId) ||
                            (sourceId === prevSpeakerId || targetId === prevSpeakerId) ||
                            (sourceId === nextSpeakerId || targetId === nextSpeakerId)) {
                            d3.select(link)
                                .style('stroke-opacity', '1.0')
                                .style('stroke-width', d => Math.max(4, Math.sqrt(linkData.weight) * 2.5));
                        } else {
                            d3.select(link)
                                .style('stroke-opacity', '0.1')
                                .style('stroke-width', d => Math.max(1, Math.sqrt(linkData.weight) * 1));
                        }
                    }
                });
            }
        }
        
        function highlightConceptsAndEdges(turnId) {
            if (!turnId || !conversationData || !conversationData.turns) return;
            
            // Use the first 50 turns for consistency
            const turnsToProcess = conversationData.turns;
            
            // Find the turn and its concepts
            const currentTurn = turnsToProcess.find(t => t.id === turnId);
            if (!currentTurn || !currentTurn.features) return;
            
            // Get active concepts for this turn
            const categoryFeatureNames = ['agreement', 'disagreement', 'new_idea', 'collaborative_building', 'curiosity', 'uncertainty'];
            const activeConcepts = [];
            currentTurn.features.forEach(feature => {
                if (categoryFeatureNames.includes(feature.name) && feature.value > 0.5) {
                    activeConcepts.push(feature.name);
                }
            });
            
            if (activeConcepts.length === 0) return;
            
            // Find previous and next turn concepts
            const currentTurnIndex = turnsToProcess.findIndex(t => t.id === turnId);
            let prevConcepts = [];
            let nextConcepts = [];
            
            if (currentTurnIndex > 0) {
                const prevTurn = turnsToProcess[currentTurnIndex - 1];
                if (prevTurn.features) {
                    prevTurn.features.forEach(feature => {
                        if (categoryFeatureNames.includes(feature.name) && feature.value > 0.5) {
                            prevConcepts.push(feature.name);
                        }
                    });
                }
            }
            
            if (currentTurnIndex < turnsToProcess.length - 1) {
                const nextTurn = turnsToProcess[currentTurnIndex + 1];
                if (nextTurn.features) {
                    nextTurn.features.forEach(feature => {
                        if (categoryFeatureNames.includes(feature.name) && feature.value > 0.5) {
                            nextConcepts.push(feature.name);
                        }
                    });
                }
            }
            
            // Highlight nodes
            const nodes = document.querySelectorAll('.node');
            const labels = document.querySelectorAll('text');
            
            nodes.forEach(node => {
                const nodeData = d3.select(node).datum();
                if (nodeData && activeConcepts.includes(nodeData.id)) {
                    d3.select(node)
                        .style('stroke', '#ffc107')
                        .style('stroke-width', '4px')
                        .style('opacity', '1');
                } else if (nodeData && (prevConcepts.includes(nodeData.id) || nextConcepts.includes(nodeData.id))) {
                    d3.select(node)
                        .style('stroke', '#28a745')
                        .style('stroke-width', '3px')
                        .style('opacity', '0.8');
                } else {
                    d3.select(node).style('opacity', '0.2');
                }
            });
            
            labels.forEach(label => {
                const labelData = d3.select(label).datum();
                if (labelData && (activeConcepts.includes(labelData.id) || 
                                 prevConcepts.includes(labelData.id) || 
                                 nextConcepts.includes(labelData.id))) {
                    d3.select(label).style('opacity', '1');
                } else {
                    d3.select(label).style('opacity', '0.2');
                }
            });
            
            // Handle edge highlighting differently for temporal flow vs aggregated mode
            const links = document.querySelectorAll('.link');
            
            if (showAllEdges && currentTurnIndex >= 0) {
                // Temporal flow mode: highlight only edges from this specific turn
                links.forEach(link => {
                    const linkData = d3.select(link).datum();
                    if (linkData) {
                        // Check if this edge corresponds to the current turn transition
                        let isRelevantEdge = false;
                        
                        // Edge from current turn to next turn (concept transitions)
                        if (linkData.turnIndex === currentTurnIndex && 
                            activeConcepts.includes(linkData.source) && 
                            nextConcepts.includes(linkData.target)) {
                            isRelevantEdge = true;
                        }
                        
                        // Edge from previous turn to current turn
                        if (linkData.turnIndex === currentTurnIndex - 1 && 
                            prevConcepts.includes(linkData.source) && 
                            activeConcepts.includes(linkData.target)) {
                            isRelevantEdge = true;
                        }
                        
                        if (isRelevantEdge) {
                            d3.select(link)
                                .style('stroke-opacity', '1.0')
                                .style('stroke-width', 4);
                        } else {
                            d3.select(link)
                                .style('stroke-opacity', '0.05')
                                .style('stroke-width', 1);
                        }
                    }
                });
            } else {
                // Aggregated mode: highlight edges connected to relevant concepts
                const allRelevantConcepts = [...activeConcepts, ...prevConcepts, ...nextConcepts];
                
                links.forEach(link => {
                    const linkData = d3.select(link).datum();
                    if (linkData) {
                        const sourceId = typeof linkData.source === 'object' ? linkData.source.id : linkData.source;
                        const targetId = typeof linkData.target === 'object' ? linkData.target.id : linkData.target;
                        
                        // Highlight edges connected to relevant concepts
                        if (allRelevantConcepts.includes(sourceId) || allRelevantConcepts.includes(targetId)) {
                            d3.select(link)
                                .style('stroke-opacity', '1.0')
                                .style('stroke-width', d => Math.max(3, Math.sqrt(linkData.weight) * 2.5));
                        } else {
                            d3.select(link)
                                .style('stroke-opacity', '0.1')
                                .style('stroke-width', d => Math.max(1, Math.sqrt(linkData.weight) * 1));
                        }
                    }
                });
            }
        }
        
        function unhighlightNodes() {
            // Reset all nodes, labels, and edges
            d3.selectAll('.node')
                .style('opacity', '1')
                .style('stroke', '#fff')
                .style('stroke-width', '2px');
                
            d3.selectAll('text')
                .style('opacity', '1');
                
            // Reset all edges to their original state
            d3.selectAll('.link')
                .style('stroke-opacity', d => currentNetworkMode === 'people' ? '1.0' : '1.0')
                .style('stroke-width', d => {
                    if (currentNetworkMode === 'people') {
                        return Math.max(3, Math.sqrt(d.weight) * 2);
                    } else {
                        return Math.max(2, Math.sqrt(d.weight) * 2);
                    }
                });
        }
        
        function renderAllEdgesNetwork(turnsToProcess) {
            const container = document.getElementById('network-container');
            container.innerHTML = '';
            
            if (!conversationData || !turnsToProcess) return;
            
            // Create ID to name mapping
            const idToName = {};
            conversationData.people.forEach(person => {
                idToName[person.id] = person.name;
            });
            
            // Calculate participation metrics for nodes
            const speakerStats = {};
            turnsToProcess.forEach(turn => {
                const speakerId = turn.speaker_id;
                const speakerName = idToName[speakerId];
                
                if (!speakerStats[speakerId]) {
                    speakerStats[speakerId] = {
                        id: speakerId,
                        name: speakerName,
                        totalWords: 0,
                        turnCount: 0
                    };
                }
                
                const wordCountFeature = turn.features.find(f => f.name === 'word_count');
                const wordCount = wordCountFeature ? wordCountFeature.value : turn.text.split(' ').length;
                speakerStats[speakerId].totalWords += wordCount;
                speakerStats[speakerId].turnCount += 1;
            });
            
            // Create individual edges for each turn transition
            const allEdges = [];
            for (let i = 0; i < turnsToProcess.length - 1; i++) {
                const currentTurn = turnsToProcess[i];
                const nextTurn = turnsToProcess[i + 1];
                
                if (currentTurn.speaker_id !== nextTurn.speaker_id) {
                    allEdges.push({
                        source: currentTurn.speaker_id,
                        target: nextTurn.speaker_id,
                        turnIndex: i,
                        totalTurns: turnsToProcess.length - 1,
                        currentTurnId: currentTurn.id,
                        nextTurnId: nextTurn.id,
                        weight: 1
                    });
                }
            }
            
            const speakers = Object.keys(speakerStats);
            
            // Create D3 visualization
            const width = container.clientWidth;
            const height = 400;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Calculate node sizes based on participation
            const maxWords = d3.max(Object.values(speakerStats), d => d.totalWords);
            const nodeSizeScale = d3.scaleLinear()
                .domain([0, maxWords])
                .range([12, 30]);
            
            // Create node data
            const nodeData = speakers.map(speakerId => ({ 
                id: Number(speakerId), 
                name: speakerStats[speakerId].name,
                size: nodeSizeScale(speakerStats[speakerId].totalWords),
                x: width / 2,
                y: height / 2
            }));
            
            // Create force simulation
            const simulation = d3.forceSimulation(nodeData)
                .force('x', d3.forceX(width / 2).strength(0.1))
                .force('y', d3.forceY(height / 2).strength(0.1))
                .force('charge', d3.forceManyBody()
                    .strength(d => -80 * Math.sqrt(d.size)))
                .force('collision', d3.forceCollide()
                    .radius(d => d.size + 10)
                    .strength(0.8))
                .alphaDecay(0.01)
                .velocityDecay(0.4);
            
            // Create color scale
            const peopleColors = ['#7B7B7B', '#A5A5A5', '#8C8C8C', '#999999', '#808080', '#737373'];
            const colorScale = d3.scaleOrdinal(peopleColors);
            
            // Create tooltip element
            const tooltip = d3.select('body').append('div')
                .attr('class', 'edge-tooltip')
                .style('opacity', 0);
            
            // Create temporal edges with varying curve heights
            const link = svg.append('g')
                .selectAll('path')
                .data(allEdges)
                .enter().append('path')
                .attr('class', 'link')
                .style('stroke', d => {
                    // Use directional grey gradient (dark source to light target)
                    return `linear-gradient(to right, #404040, #CCCCCC)`;
                })
                .style('stroke-width', 3)
                .style('stroke-opacity', 0.8)
                .style('fill', 'none')
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    // Highlight this edge
                    d3.select(this).style('stroke-width', 5).style('stroke-opacity', 1);
                    
                    // Find the turns for this edge
                    const currentTurn = turnsToProcess[d.turnIndex];
                    const nextTurn = turnsToProcess[d.turnIndex + 1];
                    
                    // Show tooltip
                    tooltip.transition().duration(200).style('opacity', 1);
                    tooltip.html(`
                        <div class="tooltip-speaker">${idToName[currentTurn.speaker_id]}:</div>
                        <div class="tooltip-text">${currentTurn.text.substring(0, 150)}${currentTurn.text.length > 150 ? '...' : ''}</div>
                        <div class="tooltip-arrow"></div>
                        <div class="tooltip-speaker">${idToName[nextTurn.speaker_id]}:</div>
                        <div class="tooltip-text">${nextTurn.text.substring(0, 150)}${nextTurn.text.length > 150 ? '...' : ''}</div>
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function(event, d) {
                    // Reset edge
                    d3.select(this).style('stroke-width', 3).style('stroke-opacity', 0.8);
                    
                    // Hide tooltip
                    tooltip.transition().duration(200).style('opacity', 0);
                });
            
            // Create nodes
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodeData)
                .enter().append('circle')
                .attr('class', 'node')
                .attr('r', d => d.size)
                .attr('fill', d => colorScale(d.id))
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // Add labels inside nodes
            const label = svg.append('g')
                .selectAll('text')
                .data(nodeData)
                .enter().append('text')
                .text(d => d.name.split(' ')[0])
                .attr('dy', '.35em')
                .attr('text-anchor', 'middle')
                .style('font-size', d => Math.min(12, d.size * 0.4) + 'px')
                .style('fill', 'white')
                .style('font-weight', 'bold')
                .style('text-shadow', '1px 1px 2px rgba(0,0,0,0.8)')
                .style('pointer-events', 'none');
            
            // Update positions on simulation tick
            simulation.on('tick', () => {
                // Constrain nodes to visualization bounds
                node.each(d => {
                    d.x = Math.max(d.size, Math.min(width - d.size, d.x));
                    d.y = Math.max(d.size, Math.min(height - d.size, d.y));
                });

                link.attr('d', d => {
                    const sourceNode = simulation.nodes().find(n => n.id === d.source);
                    const targetNode = simulation.nodes().find(n => n.id === d.target);
                    
                    if (!sourceNode || !targetNode) return '';
                    
                    const dx = targetNode.x - sourceNode.x;
                    const dy = targetNode.y - sourceNode.y;
                    const dr = Math.sqrt(dx * dx + dy * dy);
                    
                    // Calculate temporal curve height - early conversations curve higher
                    const timeProgress = d.turnIndex / d.totalTurns; // 0 to 1
                    const baseCurveHeight = 80; // Increased from 50
                    const temporalMultiplier = 1 - timeProgress; // Early = 1, late = 0
                    const curveHeight = baseCurveHeight * (0.3 + temporalMultiplier * 0.7); // Range from 24 to 80
                    
                    // Add more spread so multiple edges don't overlap
                    const edgeOffset = (d.turnIndex % 7 - 3) * 8; // Spread edges more widely
                    const finalCurveHeight = curveHeight + edgeOffset;
                    
                    // Calculate control point
                    const midX = (sourceNode.x + targetNode.x) / 2;
                    const midY = (sourceNode.y + targetNode.y) / 2 - finalCurveHeight;
                    
                    return `M ${sourceNode.x} ${sourceNode.y} Q ${midX} ${midY} ${targetNode.x} ${targetNode.y}`;
                });
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }
        
        function renderAllEdgesCategoryNetwork(turnsToProcess) {
            const container = document.getElementById('network-container');
            container.innerHTML = '';
            
            if (!conversationData || !turnsToProcess) return;
            
            // Define category features
            const categoryFeatureNames = ['agreement', 'disagreement', 'new_idea', 'collaborative_building', 'curiosity', 'uncertainty'];
            
            // Helper function to get active categories for a turn
            function getActiveCategoriesForTurn(turn) {
                const activeCategories = [];
                if (turn.features) {
                    turn.features.forEach(feature => {
                        if (categoryFeatureNames.includes(feature.name) && feature.value > 0.5) {
                            activeCategories.push(feature.name);
                        }
                    });
                }
                return activeCategories;
            }
            
            // Collect all categories and calculate stats
            const allCategories = new Set();
            const categoryStats = {};
            
            turnsToProcess.forEach(turn => {
                const activeCategories = getActiveCategoriesForTurn(turn);
                activeCategories.forEach(cat => {
                    allCategories.add(cat);
                    if (!categoryStats[cat]) {
                        categoryStats[cat] = { id: cat, name: cat, count: 0 };
                    }
                    categoryStats[cat].count += 1;
                });
            });
            
            const categories = Array.from(allCategories);
            if (categories.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: red;">No category features found with sufficient values.</p>';
                return;
            }
            
            // Create individual edges for each concept transition
            const allEdges = [];
            for (let i = 0; i < turnsToProcess.length - 1; i++) {
                const currentTurn = turnsToProcess[i];
                const nextTurn = turnsToProcess[i + 1];
                
                const currentCategories = getActiveCategoriesForTurn(currentTurn);
                const nextCategories = getActiveCategoriesForTurn(nextTurn);
                
                // Create edges for each concept-to-concept transition
                currentCategories.forEach(sourceCat => {
                    nextCategories.forEach(targetCat => {
                        if (sourceCat !== targetCat) {
                            allEdges.push({
                                source: sourceCat,
                                target: targetCat,
                                turnIndex: i,
                                totalTurns: turnsToProcess.length - 1,
                                currentTurn: currentTurn,
                                nextTurn: nextTurn,
                                weight: 1
                            });
                        }
                    });
                });
            }
            
            // Create D3 visualization
            const width = container.clientWidth;
            const height = 400;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Calculate node sizes based on frequency
            const maxCount = d3.max(Object.values(categoryStats), d => d.count);
            const nodeSizeScale = d3.scaleLinear()
                .domain([0, maxCount])
                .range([15, 35]);
            
            // Create node data
            const nodeData = categories.map(cat => ({
                id: cat,
                name: cat,
                size: nodeSizeScale(categoryStats[cat].count),
                count: categoryStats[cat].count,
                x: width / 2,
                y: height / 2
            }));
            
            // Create force simulation
            const simulation = d3.forceSimulation(nodeData)
                .force('x', d3.forceX(width / 2).strength(0.1))
                .force('y', d3.forceY(height / 2).strength(0.1))
                .force('charge', d3.forceManyBody()
                    .strength(d => -120 * Math.sqrt(d.size)))
                .force('collision', d3.forceCollide()
                    .radius(d => d.size + 15)
                    .strength(0.8))
                .alphaDecay(0.01)
                .velocityDecay(0.4);
            
            // Create color mapping
            const categoryColors = {
                'agreement': '#4CAF50',
                'disagreement': '#FF5722', 
                'new idea': '#2196F3',
                'narrative': '#9C27B0'
            };
            
            // Create tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'edge-tooltip')
                .style('opacity', 0);
            
            // Create ID to name mapping
            const idToName = {};
            conversationData.people.forEach(person => {
                idToName[person.id] = person.name;
            });
            
            // Create temporal edges with varying curve heights
            const link = svg.append('g')
                .selectAll('path')
                .data(allEdges)
                .enter().append('path')
                .attr('class', 'link')
                .style('stroke', d => {
                    const sourceColor = categoryColors[d.source] || '#666';
                    const targetColor = categoryColors[d.target] || '#666';
                    return `linear-gradient(to right, ${sourceColor}, ${targetColor})`;
                })
                .style('stroke-width', 2.5)
                .style('stroke-opacity', 0.7)
                .style('fill', 'none')
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    // Highlight this edge
                    d3.select(this).style('stroke-width', 4).style('stroke-opacity', 1);
                    
                    // Show tooltip with conversation context
                    tooltip.transition().duration(200).style('opacity', 1);
                    tooltip.html(`
                        <div class="tooltip-speaker">${idToName[d.currentTurn.speaker_id]}  ${d.source}:</div>
                        <div class="tooltip-text">${d.currentTurn.text.substring(0, 120)}${d.currentTurn.text.length > 120 ? '...' : ''}</div>
                        <div class="tooltip-arrow"></div>
                        <div class="tooltip-speaker">${idToName[d.nextTurn.speaker_id]}  ${d.target}:</div>
                        <div class="tooltip-text">${d.nextTurn.text.substring(0, 120)}${d.nextTurn.text.length > 120 ? '...' : ''}</div>
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function(event, d) {
                    // Reset edge
                    d3.select(this).style('stroke-width', 2.5).style('stroke-opacity', 0.7);
                    
                    // Hide tooltip
                    tooltip.transition().duration(200).style('opacity', 0);
                });
            
            // Create nodes
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodeData)
                .enter().append('circle')
                .attr('class', 'node')
                .attr('r', d => d.size)
                .attr('fill', d => categoryColors[d.id] || '#666')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // Add labels inside nodes
            const label = svg.append('g')
                .selectAll('text')
                .data(nodeData)
                .enter().append('text')
                .text(d => d.name.split(' ')[0])
                .attr('dy', '.35em')
                .attr('text-anchor', 'middle')
                .style('font-size', d => Math.min(11, d.size * 0.35) + 'px')
                .style('fill', 'white')
                .style('font-weight', 'bold')
                .style('text-shadow', '1px 1px 2px rgba(0,0,0,0.8)')
                .style('pointer-events', 'none');
            
            // Update positions on simulation tick
            simulation.on('tick', () => {
                // Constrain nodes to visualization bounds
                node.each(d => {
                    d.x = Math.max(d.size, Math.min(width - d.size, d.x));
                    d.y = Math.max(d.size, Math.min(height - d.size, d.y));
                });

                link.attr('d', d => {
                    const sourceNode = simulation.nodes().find(n => n.id === d.source);
                    const targetNode = simulation.nodes().find(n => n.id === d.target);
                    
                    if (!sourceNode || !targetNode) return '';
                    
                    // Calculate temporal curve height - early conversations curve higher
                    const timeProgress = d.turnIndex / d.totalTurns;
                    const baseCurveHeight = 100; // Higher curves for better separation
                    const temporalMultiplier = 1 - timeProgress;
                    const curveHeight = baseCurveHeight * (0.3 + temporalMultiplier * 0.7);
                    
                    // Add more spread for concept transitions
                    const edgeOffset = (d.turnIndex % 9 - 4) * 10; // More spread
                    const finalCurveHeight = curveHeight + edgeOffset;
                    
                    // Calculate control point
                    const midX = (sourceNode.x + targetNode.x) / 2;
                    const midY = (sourceNode.y + targetNode.y) / 2 - finalCurveHeight;
                    
                    return `M ${sourceNode.x} ${sourceNode.y} Q ${midX} ${midY} ${targetNode.x} ${targetNode.y}`;
                });
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', loadConversationData);
    </script>
</body>
</html> 